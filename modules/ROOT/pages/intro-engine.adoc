= Mule 4 の概要: 実行エンジンのスレッドと同時実行
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

Mule 4 では実行エンジンが改良され、Mule アプリケーションを簡単に開発および拡張できるようになりました。根幹的なエンジンは、非ブロック型のリアクティブアーキテクチャに基づきます。このタスク指向の実行モデルでは、非ブロック IO コールを活用して、処理方式の不適切な設定に起因するパフォーマンスの問題を回避できます。

開発面では、いくつかの大きな変更が行われています。

* エクスチェンジパターンが廃止されました。どのコネクタも応答を受信します。メッセージを非同期処理する場合は、非同期コンポーネントを使用します。
* どのフローでも常に非ブロック処理方式が使用されるため、今後は処理方式を設定する必要がありません。
* すべてのフローを対象とする 1 つのグローバルスレッドプールがあります。詳細は、xref:execution-engine.adoc[「実行エンジン」]を参照してください。

[[controlling_concurrency]]
== 同時実行の制御
Mule 4 では、スレッド設定が同時実行管理から切り離されています。フロー上、または同時実行をサポートするコンポーネント上の同時実行を制御するには、`maxConcurrency` 属性を使用して、そのコンポーネントが任意の時点で受信できる同時呼び出し数を設定します。

[source,xml,linenums]
----
<flow maxConcurrency=“1”>
  <http:listener>
  <scatter-gather maxConcurrency=“3”>
    <route/>
    <route/>
  </scatter-gather>
</flow>
----

[[thread_pools_and_tuning]]
== スレッドプールとアプリケーションの調整

前述のとおり、アプリケーションのすべてのフローを対象とする 1 つのスレッドプールができました。このため、フロー固有の動作と切り離して、全体を調整することができます。Mule では、マシンに存在する CPU コア数に応じてスレッドを割り当てます。

操作によって CPU に負荷がかかるか、さほど負荷がかからないか、IO に負荷がかかるかを、Mule の各イベントプロセッサがランタイムに通知できるようになりました。このため、ランタイムがワークロードに応じて動的に自己調整できるようになり、スレッドプールを手動で管理する必要がなくなります。その結果、Mule 4 では最適なパフォーマンスを達成するための複雑な調整が不要になります。

実行エンジンのしくみおよび実行エンジンに対して指定可能な設定についての詳細は、xref:execution-engine.adoc[「実行エンジン」]を参照してください。
