= アプリケーションデプロイメント
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: デプロイ, アプリケーション, アプリケーション, ランタイム, amc, cloudhub, オンプレミス, オンプレミス

== Mule の起動

Mule を起動するには、`<MULE_HOME>/bin/mule` を実行するか、Mule をサービスとして起動します。デフォルトでは、`<MULE_HOME>/apps` ディレクトリのアプリケーションがデプロイされます。また、(コロン **:** で区切って) 特定のアプリケーションを起動するように指定することもできます。Mule 4 では、アプリケーションの起動時にその順序が適用されます。この場合、指定されたアプリケーションのみが起動します。

実行するアプリケーションを指定して Mule を起動します。

----
mule -M-Dmule.deploy.applications=foo
----

`foo` は `$MULE_HOME/apps/foo` の Mule アプリケーションです。

この瞬間から、Mule は 3 秒ごとに `$MULE_HOME/apps/foo/mule-config.xml` の更新をチェックします。Mule で設定およびクラスの変更の再読み込みが行われるように、アプリケーションの `jar` コンテンツを更新してこのファイルを変更できます。

`mule.deploy.applications` プロパティを使用している場合、ホットデプロイメントは機能しません。  `apps` ディレクトリのアプリケーションのみがデプロイされます。新しいまたは更新されたアプリケーションは Mule が再起動するまで起動しません。

== アプリケーションのデプロイ

パッケージ化 (`jar` ファイルなど) または展開された Mule アプリケーションを `$MULE_HOME/apps` にドロップできます。Mule がすでに実行されている場合、アプリケーションは動的にデプロイされます。

[NOTE]
Mule のすべてのアプリケーションは実行時に展開され、元の `jar` は削除されます。つまり、たとえば、`jar` ファイルを `/apps` ディレクトリにドロップすると、同じ名前 (`jar` 拡張子なし) の新しいフォルダが作成され、`jar` が削除されます。

次のファイルやフォルダの有無をチェックして、アプリケーションデプロイメントが成功しているかどうかを確認します。

* `apps` ディレクトリに展開されたアプリケーションフォルダ (例: `stockTrader.kar` の場合は `$MULE_HOME/apps/stockTrader`)

* 実行中のアプリケーション用に作成されたアンカーファイル (例: `$MULE_HOME/apps/stockTrader-anchor.txt`)

アプリケーションを別の場所に保存する場合、`$MULE_HOME/apps` からアプリケーションディレクトリへのシンボリックリンクを作成して、Unix ベースのシステムに保存できます。

== 並列でのアプリケーションのデプロイ

Mule 4 では、アプリケーションを並列でデプロイできます。多数のアプリケーションをデプロイする場合、並列でデプロイすると起動時間を短縮できます。起動順序は不特定であるため、デプロイメントが失敗しないように、アプリケーションが相互連動していないことを確認します。

並列デプロイメントを有効にするには、`-M-Dmule.deployment.parall` オプションを使用して Mule を起動します。例:

`mule -M-Dmule.deployment.parallel`

`/apps` ディレクトリのすべてのアプリケーションが並列で起動します。

== アプリケーションのアンデプロイ

アプリケーションフォルダを直接削除せずに、アプリケーションのアンカーファイルのみを削除してください。

アプリケーションのアンカーファイルのみを削除すると、次のような効果があります。

* ホットデプロイメントレイヤによる干渉がなくなり、同時競合アクションの余地がなくなる。
* 一部のオペレーティングシステムで発生する可能性のある、アプリケーションによる `jar` のロックの問題が回避され、クリーンシャットダウンおよびアンデプロイメントが可能になる。

たとえば、`stockTrader` アプリケーションが実行されている場合 (アプリケーションフォルダと `$MULE_HOME/apps/stockTrader-anchor.txt` ファイルがある)、実行時にアンカーファイルのみを削除して、Mule インスタンスからアプリケーションを削除します。アプリケーションの終了後にアプリケーションフォルダが削除されます。

[NOTE]
Mule アプリケーションをアンデプロイしたら、LoggerContext が停止するまで 15 秒のタイムアウトがあります。アプリケーションのログファイルは、このタイムアウトの期限が切れないと解放されません。Windows では他のプロセスによって使用されているファイルを削除できないため、この情報は重要です。

== 実行時のアプリケーションの更新

実行時の Mule アプリケーションの更新は、クラスの変更、エンドポイントの変更 (ポートの変更など)、および再設定されたフローが関与する複雑な変更になる場合があります。そのため、アプリケーションの更新では、内部でアプリケーションが適切にシャットダウンされて再設定されます。実際、これはユーザに対して極めて透過的で、数秒以内に実行されます。

アプリケーションは、いくつかの方法で更新できます。

* 展開された既存のアプリケーションフォルダに変更をドロップし、「マスタ」設定ファイル (デフォルトではアプリケーションルートの `mule-config.xml`) を操作する。

* アプリケーションの新しい `jar` バージョンを `$MULE_HOME/apps` ディレクトリにドロップする。Mule は、これを既存のアプリケーションの更新として検出し、アプリケーションのクリーンな再デプロイメントを実行します。Mule は、古いアプリケーションフォルダへの変更を破棄します。新しいアプリケーションフォルダは、`jar` から展開されたクリーンなアプリケーションです。

どちらも既存のビルドツールと適切に統合されるため、どちらを優先するのかは、確立された開発手法によって決まります。

== リソースの共有

複数のアプリケーションを同じ場所にデプロイし、それらのアプリケーションで同じリソースを共有できる場合、共通​*ドメイン*​を作成し、そこで共通設定を定義できます。その後、複数のプロジェクトでこの設定を参照できます。これにより、たとえば、同じ HTTP ホストとポートを介してプロジェクトごとに異なるサービスを公開し、競合することなくすべてをデプロイできます。

== Runtime と管理ペイン間の通信が中断されるとどうなりますか?

Mule Runtime は管理ペインを使用して個別に実行され、インテグレーションロジックの実行や API 要求の提供を行います。このアーキテクチャにより、Runtime を戦略的 (オンプレミスやクラウド) にデプロイし、通信のボトルネックにならないようにすることができます。Runtime が管理ペインから切断されるイベントが発生すると、設計どおりに実行が継続され、インテグレーションの実行や API の提供が中断することなく行われます。ただし、新しいまたは更新されたポリシーは、接続が再確立されるまで取り込まれず、更新されません。

== 埋め込み Mule

アプリケーションサーバ、Java アプリケーション、単体テスト、IDE などに Mule が埋め込まれていて、プログラムで起動する場合、デプロイメント機能は無効になり、Mule は従来のアプリケーションモデルに従います。

== トラブルシューティング

(設定ファイルの破損などで) アプリケーションの起動に失敗した場合、Mule はアプリケーションの変更を監視しません (厳密に言うと、アプリケーションは実行されない)。そのようなアプリケーションを更新するには、更新されたアーカイブをアプリケーションフォルダにドロップしてアプリケーションを再デプロイします。

== 関連情報

* xref:shared-resources.adoc[共有リソース]
* xref:hot-deployment.adoc[ホットデプロイメント]
